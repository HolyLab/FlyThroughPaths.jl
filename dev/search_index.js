var documenterSearchIndex = {"docs":
[{"location":"makie/#Makie-integration","page":"Makie integration","title":"Makie integration","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"FlyThroughPaths.jl is integrated with Makie.jl LScenes, which are  the standard axis for 3-D plots.","category":"page"},{"location":"makie/#Orbiting-a-point","page":"Makie integration","title":"Orbiting a point","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"Here's a simple example:","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"using GLMakie, FlyThroughPaths\n\nfig, ax, plt = surface(-8..8, -8..8, Makie.peaks())","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"Now, we can use FlyThroughPaths to orbit the camera around the  current lookat point, by changing the eye position.","category":"page"},{"location":"makie/#Extracting-the-view","page":"Makie integration","title":"Extracting the view","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"First, we extract the initial view state from the axis ax.","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"view0 = capture_view(ax)","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"Note that this ViewState is a Float32 object, since that's the space Makie cameras work in.  If you want this to be Float64, you can  simply convert(ViewState{Float64}, view0).","category":"page"},{"location":"makie/#Creating-a-path","page":"Makie integration","title":"Creating a path","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"Next, we create a Path with this initial state.","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"path = Path(view0)","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"We've now created a Path object with an initial state view0.   Paths contain instructions for how to move the camera in time, and  you can add to a path by path * new_component.","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"path = path * ConstrainedMove(\n    5,          # the amount of time the move should take\n    ViewState(eyeposition = [0, 0, 46]), # the final state of the camera\n    :rotation,  # the rotation constraint (can also be `:none`)\n    :constant   # the type of interpolation (can also be `:sinusoidal`)\n)","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"Here, we've added a ConstrainedMove to the path, which moves the  camera to the point [0, 0, 46] in 5 seconds.","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"The reasons I chose these particular coordinates was to preserve the  norm (norm(view0.eyeposition) ≈ 46, norm(new) ≈ 46), so that the  rotation looks as elliptical as it can.","category":"page"},{"location":"makie/#Animating-the-camera","page":"Makie integration","title":"Animating the camera","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"Now, we can use Makie's record function to record an animation with  this:","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"record(fig, \"path.mp4\", LinRange(0, 5, 150); framerate = 30) do t\n    set_view!(ax, path(t))\nend","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"(Image: A rotating view of a surface)","category":"page"},{"location":"makie/#Zooming","page":"Makie integration","title":"Zooming","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"We can also zoom in by changing the field of view, fov:","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"path = path * ConstrainedMove(5, ViewState(; fov = 10), :none, :sinusoidal)","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"In this case, we chose sinusoidal interpolation to get a smooth zoom.","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"record(fig, \"path_zoom.mp4\", LinRange(5, 10, 150); framerate = 30) do t\n    set_view!(ax, path(t))\nend","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"(Image: A zooming view of a surface)","category":"page"},{"location":"makie/#Visualizing-the-camera's-path","page":"Makie integration","title":"Visualizing the camera's path","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"f2, a2, p2 = surface(-8..8, -8..8, Makie.peaks())\npathplot = FlyThroughPaths.plotcamerapath!(a2, path, 7)\nMakie.rotate_cam!(a2.scene, 0, pi/4, 0)\nf2","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"We can also animate the path to understand it more:","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"record(f2, \"camera_path.mp4\", LinRange(0, 5, 150); framerate = 30, update = false) do t\n    pathplot.time[] = t\nend","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"(Image: )","category":"page"},{"location":"makie/#Visualizing-the-viewing-frustum","page":"Makie integration","title":"Visualizing the viewing frustum","text":"","category":"section"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"using Makie.GeometryBasics\n# Initialize a rectangle that covers all of clip space in the initial Scene\nfrustum_clip_rect = Rect3d(Point3d(-1), Point3d(2))\n# Convert that rectangle to a mesh\nfrustum_clip_mesh = lift(ax.scene.camera.projectionview) do _\n    fcm = normal_mesh(frustum_clip_rect)\n    # Project the mesh to `ax.scene`'s data space (which is shared with `a2.scene)\n    frustum_world_points = Makie.project.(ax.scene, :clip, :data, fcm.position)\n    # Reassign the projected points to the mesh positions\n    fcm.position .= frustum_world_points\n    return fcm\nend\n\nmesh!(a2.scene, frustum_clip_mesh; color = (:blue, 0.3), shading = Makie.MultiLightShading, xautolimits = false, yautolimits = false, zautolimits = false, transparency = false,)\n\nwireframe!(a2.scene, frustum_clip_mesh; color = (:blue, 0.3), linewidth = 1, xautolimits = false)\nf2","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"Since the frustum mesh is an Observable linked to the first Scene's camera, we can animate it at no extra cost!","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"record(f2, \"camera_path_frustum.mp4\", LinRange(0, 10, 300); framerate = 30, update = false) do t\n    set_view!(ax, path(t))\n    pathplot.time[] = t\nend","category":"page"},{"location":"makie/","page":"Makie integration","title":"Makie integration","text":"(Image: A constant view of the previous surface and camera system)","category":"page"},{"location":"makie/#Bézier-paths","page":"Makie integration","title":"Bézier paths","text":"","category":"section"},{"location":"#FlyThroughPaths","page":"Home","title":"FlyThroughPaths","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FlyThroughPaths.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of the examples below assume you've loaded the package with using FlyThroughPaths.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#Generic-tools","page":"Home","title":"Generic tools","text":"","category":"section"},{"location":"#Representation-of-paths-and-view-state","page":"Home","title":"Representation of paths and view state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paths are parametrized by time t, represented in units of seconds. All paths implicitly start at t=0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The representation of view state is independent of any particular plotting package, although our parametrization is inspired by Makie's 3D camera:","category":"page"},{"location":"","page":"Home","title":"Home","text":"eyeposition: the 3d coordinates of the camera\nlookat: the 3d coordinates of the point of the camera's \"focus\" (center of gaze)\nupvector: the 3d direction that will correspond to the top of the view. Any component of this vector in the direction of lookat - eyeposition is ignored/discarded.\nfov: the angle (in degrees) of the cone centered on lookat - eyeposition that should be captured.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Set these as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FlyThroughPaths\nstate = ViewState(eyeposition=[-10, 0, 0], lookat=[0, 0, 0], upvector=[0, 0, 1], fov=45)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can set just a subset of these:","category":"page"},{"location":"","page":"Home","title":"Home","text":"newstate = ViewState(eyeposition=[-5, 0, 0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"This syntax is often used for updating a previous view; for the unspecified settings, the previous value is left intact.","category":"page"},{"location":"#Initializing-a-path","page":"Home","title":"Initializing a path","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"path = Path(state)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The path starts at state at time t=0.","category":"page"},{"location":"#Evaluating-at-a-particular-time","page":"Home","title":"Evaluating at a particular time","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once you have a path, you can get the current ViewState with path(t):","category":"page"},{"location":"","page":"Home","title":"Home","text":"path(0)\n\npath(10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"So far, nothing much is happening. Things get more interesting when we add movements.","category":"page"},{"location":"#Holding-steady","page":"Home","title":"Holding steady","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest thing you can do is insert a pause:","category":"page"},{"location":"","page":"Home","title":"Home","text":"path2 = path * Pause(5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The view will hold steady for 5 seconds. Typically you add Pause when you also plan to add other movements later.","category":"page"},{"location":"#Moving-the-camera,-option-1:-constrained-movements","page":"Home","title":"Moving the camera, option 1: constrained movements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This option is typically used for things like rotations around a center point.","category":"page"},{"location":"","page":"Home","title":"Home","text":"path2 = path * ConstrainedMove(5, newstate; constraint=:none, speed=:constant)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This indicates that over a 5-second period, the camera state gradually adopts any values specified in newstate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"path2(0)\npath2(5)\npath2(2.5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Keyword options include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"constraint (:none or :rotation): specify a value to keep constant during motion. :rotation performs a rotation around lookat. Note that if the separation between eyeposition and lookat is not constant, then the trajectory will be elliptical rather than circular.\nspeed controls how the change is made across time:\n:constant: speed is instantaneously set to a new constant value that will arrive at the endpoint at the specified time\n:sinusoidal: speed will initially increase (starting at a speed of 0), achieve a maximum at the midpoint, and then decrease back to 0.","category":"page"},{"location":"#Moving-the-camera,-option-2:-Bezier-movements","page":"Home","title":"Moving the camera, option 2: Bezier movements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With this option, you can approximately simulate the feeling of flight, preserving momentum:","category":"page"},{"location":"","page":"Home","title":"Home","text":"path2 = path * BezierMove(Δt::Real, P1::ViewState, P2::ViewState...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where a bezier path is specified as indicated in this diagram:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: bezier diagram)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The starting state, P0 in the diagram, is taken from the endpoint of path. Over the next Δt seconds, one then moves towards the last ViewState argument of bezier, orienting successively towards any prior arguments. Probably the most robust option is to use bezier(Δt, P1, P2, P3), which can be interpreted as \"depart P0 traveling towards P1, and arrive at P3 as if you had come from P2.\" The view does not actually pass through P1 and P2, but these set the initial and final tangents of the curve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To see this in action, let's create a move that \"rotates\" around the origin but moves outward (to a more distant orbit) on its way there:","category":"page"},{"location":"","page":"Home","title":"Home","text":"move = BezierMove(5, ViewState(eyeposition=[0, 10, 0]), [ViewState(eyeposition=[-20, 20, 0])])\npath2 = path * move;\npath2(2.5)","category":"page"},{"location":"#Backend-specific-tools","page":"Home","title":"Backend-specific tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These require interaction with a plotting package supported by one of the extensions. Currently supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Makie","category":"page"},{"location":"","page":"Home","title":"Home","text":"You need to load the visualization package, e.g., using GLMakie, in your session before any of the commands below will work.","category":"page"},{"location":"#Capturing-the-current-view-state","page":"Home","title":"Capturing the current view state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This can be handy for constructing a path, for example you can interactively set the approximate position and view parameters and then query them for use by the tools above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"state = capture_view(scenelike::Union{Scene, LScene})","category":"page"},{"location":"","page":"Home","title":"Home","text":"state is a ViewState object.","category":"page"},{"location":"#Setting-the-current-view-state","page":"Home","title":"Setting the current view state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"oldstate = set_view!(scenelike, path, t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This updates the current camera settings from path at time t.","category":"page"},{"location":"#Displaying-the-path","page":"Home","title":"Displaying the path","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"plot(path)","category":"page"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/#Implementing-support-for-FlyThroughPaths","page":"Developer documentation","title":"Implementing support for FlyThroughPaths","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"FlyThroughPaths operates on the ViewState model.  In order to implement support for this in a plotting package, you must implement dispatches for the following two functions:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"capture_view(obj)::ViewState: extract the current ViewState, i.e., camera settings, from obj.\nset_view!(obj, viewstate::ViewState): set the camera to the given ViewState.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Integration is already implemented for Makie; you can see that in ext/FlyThroughPathsMakieExt.jl.  The first ~20 lines are the most instructive, beyond which lie utility functions and visualization specializations.","category":"page"},{"location":"devdocs/#The-PathChange-interface","page":"Developer documentation","title":"The PathChange interface","text":"","category":"section"}]
}
